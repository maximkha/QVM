var qGates = {};
// https://en.wikipedia.org/wiki/Quantum_logic_gate#Pauli-X_gate
qGates.Hammard = { nI: 1, nO: 1, mat: new Matrix(0, 0).From2dRealArr([[1, 1], [1, -1]]).Scalar(new Complex(new Decimal(1).div(new Decimal(2).sqrt()),0)) };
qGates.PauliX = { nI: 1, nO: 1, mat: new Matrix(0, 0).From2dRealArr([[0, 1], [1, 0]]) };
qGates.PauliY = { nI: 1, nO: 1, mat: new Matrix(0, 0).From2dComplexArr([[new Complex(0, 0), new Complex(0, -1)], [new Complex(0, 1), new Complex(0, 0)]]) };
qGates.PauliZ = { nI: 1, nO: 1, mat: new Matrix(0, 0).From2dRealArr([[1, 0], [0, -1]]) };
qGates.SqrtNot = { nI: 1, nO: 1, mat: new Matrix(0, 0).From2dComplexArr([[new Complex(1, 1), new Complex(1, -1)], [new Complex(1, -1), new Complex(1, 1)]]).Scalar(new Complex(1 / 2, 0)) };
qGates.PhaseShift = function (phi) { return { nI: 1, nO: 1, mat: new Matrix(0, 0).From2dComplexArr([[new Complex(1, 0), new Complex(0, 0)], [new Complex(0, 0), eulerFormula(phi)]]) }; };
qGates.Swap = { nI: 2, nO: 2, mat: new Matrix(0, 0).From2dRealArr([[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1]]) };
qGates.SqrtSwap = { nI: 2, nO: 2, mat: new Matrix(0, 0).From2dComplexArr([[new Complex(1, 0), new Complex(0, 0), new Complex(0, 0), new Complex(0, 0)], [new Complex(0, 0), new Complex(1 / 2, 1 / 2), new Complex(1 / 2, -1 / 2), new Complex(0, 0)], [new Complex(0, 0), new Complex(1 / 2, -1 / 2), new Complex(1 / 2, 1 / 2), new Complex(0, 0)], [new Complex(0, 0), new Complex(0, 0), new Complex(0, 0), new Complex(1, 0)]]) };
qGates.CNot = { nI: 2, nO: 2, mat: new Matrix(0, 0).From2dRealArr([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]) };
//No U gate
qGates.CCNot = { nI: 3, nO: 3, mat: new Matrix(0, 0).From2dRealArr([[1,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,1,0]]) };
qGates.CSwap = { nI: 3, nO: 3, mat: new Matrix(0, 0).From2dRealArr([[1,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0],[0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1]]) };
qGates.IsingXX = function (phi) { return {nI: 3, nO: 3, mat: new Matrix(0, 0).From2dComplexArr([[new Complex(1, 0), new Complex(0, 0), new Complex(0, 0), eulerFormula(phi.sub(new Decimal(-1).acos().div(2)))], [new Complex(0, 0), new Complex(1, 0), new Complex(0, -1), new Complex(0, 0)], [new Complex(0, 0), new Complex(0, -1), new Complex(1, 0), new Complex(0, 0)], [eulerFormula(phi.neg().sub(new Decimal(-1).acos().div(2))), new Complex(0, 0), new Complex(0, 0), new Complex(1, 0)]])}; };
qGates.IsingYY = function (phi) { return {nI: 3, nO: 3, mat: new Matrix(0, 0).From2dComplexArr([[new Complex(phi.cos(), 0), new Complex(0, 0), new Complex(0, 0), new Complex(0, phi.sin())], [new Complex(0, 0), new Complex(phi.cos(), 0), new Complex(0, phi.sin().neg()), new Complex(0, 0)], [new Complex(0, 0), new Complex(0, phi.sin().neg()), new Complex(phi.cos(), 0), new Complex(0, 0)], [new Complex(0, phi.sin()), new Complex(0, 0), new Complex(0, 0), new Complex(phi.cos(), 0)]])}; };
qGates.IsingZZ = function (phi) { return {nI: 3, nO: 3, mat: new Matrix(0, 0).From2dComplexArr([[eulerFormula(phi.div(2)), new Complex(0, 0), new Complex(0, 0), new Complex(0, 0)], [new Complex(0, 0), eulerFormula(phi.div(2).neg()), new Complex(0, 0), new Complex(0, 0)], [new Complex(0, 0), new Complex(0, 0), eulerFormula(phi.div(2).neg()), new Complex(0, 0)], [new Complex(0, 0), new Complex(0, 0), new Complex(0, 0), eulerFormula(phi.div(2))]])}; };
//https://www.quantum-inspire.com/kbase/s-gate/
qGates.S = { nI: 1, nO: 1, mat: new Matrix(0, 0).From2dComplexArr([[new Complex(1, 0), new Complex(0, 0)], [new Complex(0, 0), new Complex(0, 1)]]) };
qGates.I = { nI: 1, nO: 1, mat: new Matrix(0, 0).From2dRealArr([[1, 0], [0, 1]]) };
qGates.Rx = function (phi) { return { nI: 1, nO: 1, mat: new Matrix(0, 0).From2dComplexArr([[new Complex(phi.div(2).cos(), 0), new Complex(0, phi.div(2).sin().neg())], [new Complex(0, phi.div(2).sin().neg()), new Complex(phi.div(2).cos(), 0)]]) }; };
qGates.Ry = function (phi) { return { nI: 1, nO: 1, mat: new Matrix(0, 0).From2dComplexArr([[new Complex(phi.div(2).cos(), 0), new Complex(phi.div(2).sin().neg(), 0)], [new Complex(phi.div(2).sin(), 0), new Complex(phi.div(2).cos(), 0)]]) }; };
qGates.Rz = function (phi) { return { nI: 1, nO: 1, mat: new Matrix(0, 0).From2dComplexArr([[eulerFormula(phi.div(2)), new Complex(0, 0)], [new Complex(0, 0), eulerFormula(phi.div(2).neg())]]) }; }; // TODO: test this
qGates.SDagger = { nI: 1, nO: 1, mat: new Matrix(0, 0).From2dComplexArr([[new Complex(1, 0), new Complex(0, 0)], [new Complex(0, 0), new Complex(0, -1)]]) };
qGates.T = { nI: 1, nO: 1, mat: new Matrix(0, 0).From2dComplexArr([[new Complex(1, 0), new Complex(0, 0)], [new Complex(0, 0), eulerFormula(new Decimal(-1).acos().div(4))]]) };
qGates.TDagger = { nI: 1, nO: 1, mat: new Matrix(0, 0).From2dComplexArr([[new Complex(1, 0), new Complex(0, 0)], [new Complex(0, 0), eulerFormula(new Decimal(-1).acos().div(4).neg())]]) }; // TODO: test this
qGates.CZ = { nI: 2, nO: 2, mat: new Matrix(0, 0).From2dRealArr([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, -1]]) };
qGates.CR = function (phi) { return { nI: 2, nO: 2, mat: new Matrix(0, 0).From2dComplexArr([[new Complex(1, 0), new Complex(0, 0), new Complex(0, 0), new Complex(0, 0)], [new Complex(0, 0), new Complex(1, 0), new Complex(0, 0), new Complex(0, 0)], [new Complex(0, 0), new Complex(0, 0), new Complex(1, 0), new Complex(0, 0)], [new Complex(0, 0), new Complex(0, 0), new Complex(0, 0), eulerFormula(phi)]]) }; };
qGates.CRk = function (k) { return { nI: 2, nO: 2, mat: new Matrix(0, 0).From2dComplexArr([[new Complex(1, 0), new Complex(0, 0), new Complex(0, 0), new Complex(0, 0)], [new Complex(0, 0), new Complex(1, 0), new Complex(0, 0), new Complex(0, 0)], [new Complex(0, 0), new Complex(0, 0), new Complex(1, 0), new Complex(0, 0)], [new Complex(0, 0), new Complex(0, 0), new Complex(0, 0), eulerFormula(new Decimal(2).mul(new Decimal(-1).acos()).div(new Decimal(2).pow(k)))]]) }; };
